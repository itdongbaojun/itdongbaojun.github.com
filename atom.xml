<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[董宝君的iOS技术博客]]></title>
  <link href="http://itdongbaojun.github.io/atom.xml" rel="self"/>
  <link href="http://itdongbaojun.github.io/"/>
  <updated>2014-11-23T23:29:23+08:00</updated>
  <id>http://itdongbaojun.github.io/</id>
  <author>
    <name><![CDATA[董宝君]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[利用Octopress写Blog的常用命令]]></title>
    <link href="http://itdongbaojun.github.io/blog/2014/11/23/li-yong-octopressxie-blogde-chang-yong-ming-ling/"/>
    <updated>2014-11-23T22:01:10+08:00</updated>
    <id>http://itdongbaojun.github.io/blog/2014/11/23/li-yong-octopressxie-blogde-chang-yong-ming-ling</id>
    <content type="html"><![CDATA[<h3>前言</h3>

<p>关于介绍如何搭建基于github的博客的优秀文章有很多，如果你想从零开始搭建一个基于github的博客系统，你可以看一下<code>唐巧</code>这篇Blog<a href="http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/">象写程序一样写博客：搭建基于github的博客</a>，介绍的很详细、很清楚。今天在这里只是简单的记录一下搭建博客系统成功后发布博客的简单的流程。<!-- more --></p>

<h3>创建</h3>

<p>Octopress为我们提供了一些task来创建博文和页面。博文必须存储在<code>source/_posts</code>目录下，并且需要按照Jekyll的命名规范对文章进行命名：<code>YYYY-MM-DD-post-title.markdown</code>。文章的名字会被当做url的一部分，而其中的日期用于对博文的区分和排序。</p>

<p>通过Octopress提供的task可以正确的按照命名规范创建一个博文，并且在博文中会附带常用的一些yaml元数据。命令如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="err">$</span> <span class="n">rake</span> <span class="n">new_post</span><span class="p">[</span><span class="s">&quot;title&quot;</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中title为博文的文件名，创建出来的文件默认是markdown格式。这个文件在<code>source/_posts/xxx</code>路径下，打开文件可以看到如下的内容:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="o">---</span>
</span><span class='line'><span class="nl">layout:</span> <span class="n">post</span>
</span><span class='line'><span class="nl">title:</span> <span class="s">&quot;title&quot;</span>
</span><span class='line'><span class="nl">date:</span> <span class="mi">2014</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mi">23</span> <span class="mi">22</span><span class="o">:</span><span class="mo">01</span><span class="o">:</span><span class="mi">10</span> <span class="o">+</span><span class="mi">0800</span>
</span><span class='line'><span class="nl">comments:</span> <span class="kc">true</span>
</span><span class='line'><span class="nl">categories:</span>
</span><span class='line'><span class="o">---</span>
</span></code></pre></td></tr></table></div></figure>


<h3>内容</h3>

<p>接下来就可以在上面生成的那个文件中写博客啦！这里有一点需要说明的就是，你可以在文章合适的地方插入<code>&lt;!-- more --&gt;</code>，这样就可以实现在文章的预览首页不显示全部内容，会有一个“Continue →”按钮来查查看整篇文章。</p>

<h3>生成和预览</h3>

<p>可以使用下面的命令生成静态文件</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="err">$</span> <span class="n">rake</span> <span class="n">generate</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以使用下面的命令检测文件变化，实时生成新内容</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="err">$</span> <span class="n">rake</span> <span class="n">watch</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以使用下面的命令生成在本机4000端口访问的内容</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="err">$</span> <span class="n">rake</span> <span class="n">preview</span>     <span class="err">#</span> <span class="err">访问</span><span class="nl">http:</span><span class="c1">//localhost:4000就可以</span>
</span></code></pre></td></tr></table></div></figure>


<h3>发布</h3>

<p>当你把文章内容写好了，同时本地预览效果也没有问题了，这个时候就可以发布文章了，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="err">$</span> <span class="n">git</span> <span class="n">add</span> <span class="p">.</span>
</span><span class='line'><span class="err">$</span> <span class="n">git</span> <span class="n">commit</span> <span class="o">-</span><span class="n">am</span> <span class="s">&quot;Some comment here.&quot;</span>
</span><span class='line'><span class="err">$</span> <span class="n">git</span> <span class="n">push</span> <span class="n">origin</span> <span class="n">source</span>
</span><span class='line'><span class="err">$</span> <span class="n">rake</span> <span class="n">deploy</span>              <span class="err">#发布</span>
</span></code></pre></td></tr></table></div></figure>


<h3>总结</h3>

<p>是不是很简单，这样就搞定了，哈哈!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[采用现代Objective-C]]></title>
    <link href="http://itdongbaojun.github.io/blog/2014/03/18/cai-yong-xian-dai-objective-c/"/>
    <updated>2014-03-18T14:00:10+08:00</updated>
    <id>http://itdongbaojun.github.io/blog/2014/03/18/cai-yong-xian-dai-objective-c</id>
    <content type="html"><![CDATA[<h3>前言</h3>

<p>这些年以来，随着<em>Objective-C</em>语言的不断发展和进化。尽管这门语言的核心概念和实践都保持不变，但是这其中的一部分已经有了显著的提升和改变。为了让我们更加容易的写出正确的代码，现代<em>Objective-C</em>语言提升了类型安全、内存管理、性能以及一些其他的方面。因此，在我们现在的以及将来的项目中采用这些新的改变让我们的代码变得更加一致、更加可读、更加可维护。</p>

<p><em>Xcode</em>提供了一个工具来帮助我们做出这些结构上的改变。但是在使用这个工具之前，我们需要知道<em>Xcode</em>对我们的代码做出了什么样改变，以及它为什么要做出这样的改变。这篇文章会突出介绍如何在我们的代码中采用一些最有效、最有用的现代<em>Objective-C</em>编程方法。</p>

<h3>instancetype</h3>

<p>使用关键字<code>instancetype</code>作为需要返回一个类(<em>或者这个类的子类</em>)实例的方法的返回值类型。这些方法包括<code>alloc</code>，<code>init</code>，以及类工厂方法。</p>

<p>在合适的场合使用<code>instancetype</code>代替<code>id</code>类型来提高你的Objective-C代码的类型安全。例如，看一下下面的代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="c1">// .h</span>
</span><span class='line'><span class="err">@</span><span class="n">interface</span> <span class="n">MyObject</span> <span class="o">:</span> <span class="n">NSObject</span>
</span><span class='line'><span class="o">+</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="n">factoryMethodA</span><span class="p">;</span>
</span><span class='line'><span class="o">+</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">factoryMethodB</span><span class="p">;</span>
</span><span class='line'><span class="err">@</span><span class="n">end</span>
</span><span class='line'><span class="c1">// .m</span>
</span><span class='line'><span class="err">@</span><span class="n">implementation</span> <span class="n">MyObject</span>
</span><span class='line'><span class="o">+</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="n">factoryMethodA</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[[[</span><span class="n">self</span> <span class="n">class</span><span class="p">]</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span> <span class="p">}</span>
</span><span class='line'><span class="o">+</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">factoryMethodB</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[[[</span><span class="n">self</span> <span class="n">class</span><span class="p">]</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span> <span class="p">}</span>
</span><span class='line'><span class="err">@</span><span class="n">end</span>
</span><span class='line'><span class="c1">// 调用</span>
</span><span class='line'><span class="kt">void</span> <span class="n">doSomething</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSUInteger</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
</span><span class='line'>    <span class="n">x</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MyObject</span> <span class="n">factoryMethodA</span><span class="p">]</span> <span class="n">count</span><span class="p">];</span> <span class="c1">// Return type of +factoryMethodA is taken to be &quot;MyObject *&quot;</span>
</span><span class='line'>    <span class="n">y</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MyObject</span> <span class="n">factoryMethodB</span><span class="p">]</span> <span class="n">count</span><span class="p">];</span> <span class="c1">// Return type of +factoryMethodB is &quot;id&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>由于类方法<code>+factoryMethodA</code>的返回值类型是<code>instancetype</code>，这个类型的消息表现为<code>MyObject *</code>。由于<code>MyObject</code>没有<code>-count</code>方法，编译器报了一个关于<code>x</code>行的警告：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">main</span><span class="p">.</span><span class="nl">m:</span> <span class="err">’</span><span class="n">MyObject</span><span class="err">’</span> <span class="n">may</span> <span class="n">not</span> <span class="n">respond</span> <span class="n">to</span> <span class="err">‘</span><span class="n">count</span><span class="err">’</span>
</span></code></pre></td></tr></table></div></figure>


<p>然而，类方法<code>+factoryMethodB</code>的返回值值类型为<code>id</code>类型，编译器就不会报关于<code>y</code>行的警告啦。因为一个<code>id</code>类型的对象可以是任何类，同时，一个叫做<code>-count</code>的方法总是存在于一些类的某个地方，因此，类方法<code>+factoryMethodB</code>的返回值来实现这个方法对于编译器来说是可能的。</p>

<p>为了使<code>instancetype</code>类工厂方法能够拥有正确的子类化行为，确保我们在分配类时使用<code>[self class]</code>而不是直接使用类名。遵循这个约定以确保编译器能够正确的推断出子类的类型。例如：子类化上一个例子中的<code>MyObject</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="err">@</span><span class="n">interface</span> <span class="n">MyObjectSubclass</span> <span class="o">:</span> <span class="n">MyObject</span>
</span><span class='line'><span class="err">@</span><span class="n">end</span>
</span><span class='line'><span class="kt">void</span> <span class="n">doSomethingElse</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSString</span> <span class="o">*</span><span class="n">aString</span> <span class="o">=</span> <span class="p">[</span><span class="n">MyObjectSubclass</span> <span class="n">factoryMethodA</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于这段代码编译器给出了如下的警告：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">main</span><span class="p">.</span><span class="nl">m:</span> <span class="n">Incompatible</span> <span class="n">pointer</span> <span class="n">types</span> <span class="n">initializing</span> <span class="err">’</span><span class="n">NSString</span> <span class="o">*</span><span class="err">’</span> <span class="n">with</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">of</span> <span class="n">type</span> <span class="err">’</span><span class="n">MyObjectSubclass</span> <span class="o">*</span><span class="err">’</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这个例子中，<code>+factoryMethodA</code>消息发送后返回了一个<code>MyObjectSubclass</code>类型的对象，是消息接收者类型的对象。编译器因此会相应的认为<code>+factoryMethodA</code>方法的返回值应该是<code>MyObjectSubclass</code>的子类，而不是其工厂方法中声明的那个父类。</p>

<h3>如何采用？</h3>

<p>在你的代码中，用<code>instancetype</code>类型恰当的代替出现<code>id</code>返回值类型的地方。比较典型的就是<code>init</code>方法和类工厂方法。尽管编译器会自动的将以“alloc”，“init”，“new”开头的方法的返回值类型由<code>id</code>转为<code>instancetype</code>，但是却不会为其他的方法进行自动转换。Objective-C的约定是为所有的方法明确的使用<code>instancetype</code>返回值类型。</p>

<p>请注意，你应该只是对于返回值类型用<code>instancetype</code>替换<code>id</code>，在其他处的代码是不可以的。与<code>id</code>类型不同的是，关键字<code>instancetype</code>只能用于方法声明中的返回值类型。</p>

<p>例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="err">@</span><span class="n">interface</span> <span class="n">MyObject</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">myFactoryMethod</span><span class="p">;</span>
</span><span class='line'><span class="err">@</span><span class="n">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>应该转变成：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="err">@</span><span class="n">interface</span> <span class="n">MyObject</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="n">myFactoryMethod</span><span class="p">;</span>
</span><span class='line'><span class="err">@</span><span class="n">end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Properties</h3>

<p>Objective-C的<em>property</em>是使用<code>@property</code>语法声明的公有方法或者私有方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="err">@</span><span class="n">property</span> <span class="p">(</span><span class="n">readonly</span><span class="p">,</span> <span class="n">getter</span><span class="o">=</span><span class="n">isBlue</span><span class="p">)</span> <span class="n">BOOL</span> <span class="n">blue</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>Properties</code>捕获对象的状态。它能够表达出对象的内在的属性以及和其他对象之间的关系。<code>Properties</code>提供了一个安全、方便的方式与这些属性进行交互而不用自己写一组自定义的存取方法（尽管属性允许我们在需要的时候自定义<code>getters</code>和<code>setters</code>）。</p>

<p>在越来越多的场合下使用属性代替实例变量有以下的益处：</p>

<ul>
<li><strong>自动合成<code>getters</code>和<code>setters</code>。</strong>当你声明一个<code>property</code>，会默认自动为你创建<code>getter</code>和<code>setter</code>方法。</li>
<li><strong>意图表达更加清楚的一组方法。</strong>由于存取方法的命名规范，能够非常准确的表达<code>getter</code>和<code>setter</code>方法正在做什么。</li>
<li><strong><code>Property</code>关键字表达表达了一些关于行为的额外信息。</strong>属性为声明像<code>assign</code>(vs <code>copy</code>)，<code>weak</code>，<code>atomic</code>（vs <code>nonatomic</code>）等行为提供了可能。</li>
</ul>


<p>属性方法遵循一个简单的命名规范。<em>getter</em>方法名为属性的名字（例如：<code>date</code>），<em>setter</em>方法名位属性名带上<em>set</em>前缀，采用驼峰写法（例如：<code>setDate</code>）。布尔值属性的命名约定是的<em>getter</em>方法是以“is”开头的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="err">@</span><span class="n">property</span> <span class="p">(</span><span class="n">readonly</span><span class="p">,</span> <span class="n">getter</span><span class="o">=</span><span class="n">isBlue</span><span class="p">)</span> <span class="n">BOOL</span> <span class="n">blue</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>因此，下面的每一个方法都是能够工作的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">color</span><span class="p">.</span><span class="n">blue</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">color</span><span class="p">.</span><span class="n">isBlue</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'><span class="k">if</span> <span class="p">([</span><span class="n">color</span> <span class="n">isBlue</span><span class="p">])</span> <span class="p">{</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当想要决定什么可以是<code>property</code>时，一定要记住，下面的这些情况不能为属性：</p>

<ul>
<li><code>init</code>方法</li>
<li><code>copy</code>方法，<code>mutableCopy</code>方法</li>
<li>类工厂方法</li>
<li>方法启动了一个操作，同时返回一个<code>Bool</code>值</li>
<li>方法明确改变了内部状态作为一个getter的副作用。</li>
</ul>


<p>此外，在你的代码中识别潜在的属性时，需要考虑下面的这些原则：</p>

<ul>
<li>一个read/write property 拥有两个存取方法。setter方法拥有一个参数，无返回值，getter方法没有参数，有一个返回值。如果你想转变这组方法称为property，需要标注为<code>readwrite</code>关键字。</li>
<li>一个read-only property只有一个存取方法，就是getter方法，无参数，有一个返回值。如果想要转变这个方法为property时，需要标注<code>readonly</code>关键字。</li>
<li>getter方法应该是<em>idempotent</em>（如果getter方法被调用两次，第二次调用的结果和第一次调用的结果应该是相同的）。然而，对于getter方法是合理的去计算它每一次被调用的值。</li>
</ul>


<h3>如何采用？</h3>

<p>识别出一组方法，使其有资格转化成一个property，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="o">-</span> <span class="p">(</span><span class="n">NSColor</span> <span class="o">*</span><span class="p">)</span><span class="n">backgroundColor</span><span class="p">;</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">setBackgroundColor:</span><span class="p">(</span><span class="n">NSColor</span> <span class="o">*</span><span class="p">)</span><span class="n">color</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用<code>@property</code>语法选择合理的关键字来声明成属性：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="err">@</span><span class="n">property</span> <span class="p">(</span><span class="n">copy</span><span class="p">)</span> <span class="n">NSColor</span> <span class="o">*</span><span class="n">backgroundColor</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Enumeration Macros</h3>

<p><code>NS_ENUM</code>和<code>NS_OPTIONS</code>宏提供了一个方便、简单的方式来定义基于<strong>C</strong>语言的枚举和选择。这些宏在Xcode中改善了代码实现，明确指定枚举、选择的类型以及大小。除此之外，这种声明枚举的方式可以很好的兼容旧的的编译器，新的声明方法可以解释基础类型的信息。</p>

<p>使用<code>NS_ENUM</code>宏来定义<em>enumerations</em>，一组不同的值的集合：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">typedef</span> <span class="n">NS_ENUM</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">,</span> <span class="n">UITableViewCellStyle</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">UITableViewCellStyleDefault</span><span class="p">,</span>
</span><span class='line'>        <span class="n">UITableViewCellStyleValue1</span><span class="p">,</span>
</span><span class='line'>        <span class="n">UITableViewCellStyleValue2</span><span class="p">,</span>
</span><span class='line'>        <span class="n">UITableViewCellStyleSubtitle</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>NS_ENUM</code>宏帮助定义枚举的名字和类型，<code>UITableViewCellStyle</code>宏的类型为<code>NSInteger</code>。枚举的类型应该是<code>NSInteger</code>。</p>

<p>使用<code>NS_OPTIONS</code>宏来定义<em>options</em>，一组结合在一起的位掩码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">typedef</span> <span class="n">NS_OPTIONS</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">,</span> <span class="n">UIViewAutoresizing</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">UIViewAutoresizingNone</span>                 <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>        <span class="n">UIViewAutoresizingFlexibleLeftMargin</span>   <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>        <span class="n">UIViewAutoresizingFlexibleWidth</span>        <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
</span><span class='line'>        <span class="n">UIViewAutoresizingFlexibleRightMargin</span>  <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>
</span><span class='line'>        <span class="n">UIViewAutoresizingFlexibleTopMargin</span>    <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span>
</span><span class='line'>        <span class="n">UIViewAutoresizingFlexibleHeight</span>       <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">,</span>
</span><span class='line'>        <span class="n">UIViewAutoresizingFlexibleBottomMargin</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>像枚举一样，<code>NS_OPTIONS</code>宏定义了名字和类型。然而，<em>options</em>的类型通常是<code>NSUInteger</code>。</p>

<h3>如何采用？</h3>

<p>替代你的<code>enum</code>声明，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">enum</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">UITableViewCellStyleDefault</span><span class="p">,</span>
</span><span class='line'>        <span class="n">UITableViewCellStyleValue1</span><span class="p">,</span>
</span><span class='line'>        <span class="n">UITableViewCellStyleValue2</span><span class="p">,</span>
</span><span class='line'>        <span class="n">UITableViewCellStyleSubtitle</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="k">typedef</span> <span class="n">NSInteger</span> <span class="n">UITableViewCellStyle</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用<code>NS_ENUM</code>语法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">typedef</span> <span class="n">NS_ENUM</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">,</span> <span class="n">UITableViewCellStyle</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">UITableViewCellStyleDefault</span><span class="p">,</span>
</span><span class='line'>        <span class="n">UITableViewCellStyleValue1</span><span class="p">,</span>
</span><span class='line'>        <span class="n">UITableViewCellStyleValue2</span><span class="p">,</span>
</span><span class='line'>        <span class="n">UITableViewCellStyleSubtitle</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是，当你使用<code>enum</code>来定义一个位掩码(bitmask)，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">enum</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">UIViewAutoresizingNone</span>                 <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>        <span class="n">UIViewAutoresizingFlexibleLeftMargin</span>   <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>        <span class="n">UIViewAutoresizingFlexibleWidth</span>        <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
</span><span class='line'>        <span class="n">UIViewAutoresizingFlexibleRightMargin</span>  <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>
</span><span class='line'>        <span class="n">UIViewAutoresizingFlexibleTopMargin</span>    <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span>
</span><span class='line'>        <span class="n">UIViewAutoresizingFlexibleHeight</span>       <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">,</span>
</span><span class='line'>        <span class="n">UIViewAutoresizingFlexibleBottomMargin</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="k">typedef</span> <span class="n">NSUInteger</span> <span class="n">UIViewAutoresizing</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用<code>NS_OPTIONS</code>宏：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">typedef</span> <span class="n">NS_OPTIONS</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">,</span> <span class="n">UIViewAutoresizing</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">UIViewAutoresizingNone</span>                 <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>        <span class="n">UIViewAutoresizingFlexibleLeftMargin</span>   <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>        <span class="n">UIViewAutoresizingFlexibleWidth</span>        <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
</span><span class='line'>        <span class="n">UIViewAutoresizingFlexibleRightMargin</span>  <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>
</span><span class='line'>        <span class="n">UIViewAutoresizingFlexibleTopMargin</span>    <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span>
</span><span class='line'>        <span class="n">UIViewAutoresizingFlexibleHeight</span>       <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">,</span>
</span><span class='line'>        <span class="n">UIViewAutoresizingFlexibleBottomMargin</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<h3>自动引用计数（ARC）</h3>

<p>自动引用引用计数（ARC）是编译器特性，为Objective-C对象提供内存管理，不再需要记住什么时候应该使用<code>retain</code>，<code>release</code>，和<code>autorelease</code>。ARC帮你管理对象的生存周期，在编译器帮你自动插入适当的内存管理代码，编译器也会在合适的时机帮你生成<code>dealloc</code>方法。</p>

<h3>如何采用？</h3>

<p>Xcode提供了ARC自动转换工具。选择ARC迁移工具：选择：<strong>Edit</strong> > <strong>Refactor</strong> > <strong>Convert to Objective-C ARC</strong>。更多信息请查看：<a href="https://developer.apple.com/library/ios/releasenotes/objectivec/rn-transitioningtoarc/introduction/introduction.html">Transitioning to ARC Release Notes</a></p>

<h3>相关链接</h3>

<p><a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html?utm_campaign=iOS_Dev_Weekly_Issue_137&amp;utm_medium=email&amp;utm_source=iOS%2BDev%2BWeekly#//apple_ref/doc/uid/TP40014150">Adopting Modern Objective-C</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用CocoaPods来管理iOS项目的依赖库]]></title>
    <link href="http://itdongbaojun.github.io/blog/2013/12/28/shi-yong-cocoapodslai-guan-li-iosxiang-mu-de-yi-lai-ku/"/>
    <updated>2013-12-28T17:17:25+08:00</updated>
    <id>http://itdongbaojun.github.io/blog/2013/12/28/shi-yong-cocoapodslai-guan-li-iosxiang-mu-de-yi-lai-ku</id>
    <content type="html"><![CDATA[<p><img src="http://itdongbaojun.github.io/images/blogImgs/cocoapods-logo.png" alt="CocoaPods Logo" /></p>

<h3>前言</h3>

<p>细细算来，我接触iOS已经有<em>1.5f</em>年的时间了，虽然其中有差不多一年的时间是在大四经历<em>自学和实习</em>的这个阶段。抛去那段时间不算，毕业后在现在的公司工作差不多半年了&hellip;</p>

<p>在经历过的几个项目上基本上每一个都会用到第三方开源库，比如<code>SDWebImage</code>、<code>AFNetworking</code>、<code>MBProgressHUD</code>等。然而，每次把这些第三方库导入到我们的项目中要配置一些选项以及添加第三方库本身依赖的系统框架，这个工作是重复的而且非常没有技术含量。有没有什么工具能替代我们做这些工作呢？</p>

<p>一直到最近几天才知道，业界早已有了为iOS项目提供依赖管理的工具(<em>我深深的感觉到我还没入行就先落伍了</em>)，这个工具就是：<a href="http://beta.cocoapods.org">CocoaPods</a>。</p>

<h3>CocoaPods简介</h3>

<p>CocoaPods是一个负责管理iOS项目中第三方开源库的工具。CocoaPods的<a href="https://github.com/CocoaPods/CocoaPods">项目源码</a>在Github上管理。该项目开始于2011年8月12日，在这两年多的时间里，它持续保持活跃更新。开发iOS项目不可避免地要使用第三方开源库，CocoaPods的出现使得我们可以节省设置和更新第三方开源库的时间</p>

<p>在我们有了CocoaPods这个工具之后，只需要将用到的第三方开源库放到一个名为Podfile的文件中，然后在命令行执行<code>$ pod install</code>命令。CocoaPods就会自动将这些第三方开源库的源码下载下来，并且为我的工程设置好相应的系统依赖和编译参数</p>

<h3>CocoaPods的安装及使用</h3>

<h3>安装</h3>

<p>安装的方式非常简单，Mac下已经自带了ruby，只要使用ruby的gem命令就可以安装了。打开的Mac的终端，在终端运行下面的命令：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="err">$</span> <span class="p">[</span><span class="n">sudo</span><span class="p">]</span> <span class="n">gem</span> <span class="n">install</span> <span class="n">cocoapods</span>
</span><span class='line'><span class="err">$</span> <span class="n">pod</span> <span class="n">setup</span>
</span></code></pre></td></tr></table></div></figure>


<p>
说明：执行<code>$ pod setup</code>这步可能比较慢，需要多等待一段时间，也可能是我网络的问题</p>

<h3>更新</h3>

<p>当然我们也可以更新我们的CocoaPods，同样也是使用ruby的gem命令：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="err">$</span> <span class="p">[</span><span class="n">sudo</span><span class="p">]</span> <span class="n">gem</span> <span class="n">update</span> <span class="n">cocoapods</span>
</span></code></pre></td></tr></table></div></figure>


<p>
然而你也可以更新CocoaPods的预览版，执行下面的命令：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="err">$</span> <span class="p">[</span><span class="n">sudo</span><span class="p">]</span> <span class="n">gem</span> <span class="n">update</span> <span class="n">cocoapods</span> <span class="o">--</span><span class="n">pre</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>查找第三方库</h3>

<p>如果我们不知道cocoaPods管理的库中，是否有你想要的库，那么你可以通过<code>$ pod search xxx</code>命令进行查找，以下是我用<code>$ pod search sdwebimage</code>查找到的所有可用的库：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="o">-&gt;</span> <span class="n">SDWebImage</span> <span class="p">(</span><span class="mf">3.5.1</span><span class="p">)</span>
</span><span class='line'>   <span class="n">Asynchronous</span> <span class="n">image</span> <span class="n">downloader</span> <span class="n">with</span> <span class="n">cache</span> <span class="n">support</span> <span class="n">with</span> <span class="n">an</span> <span class="n">UIImageView</span>
</span><span class='line'>   <span class="n">category</span><span class="p">.</span>
</span><span class='line'>   <span class="n">pod</span> <span class="err">&#39;</span><span class="n">SDWebImage</span><span class="err">&#39;</span><span class="p">,</span> <span class="err">&#39;</span><span class="o">~&gt;</span> <span class="mf">3.5.1</span><span class="err">&#39;</span>
</span><span class='line'>   <span class="o">-</span> <span class="nl">Homepage:</span> <span class="nl">https:</span><span class="c1">//github.com/rs/SDWebImage</span>
</span><span class='line'>   <span class="o">-</span> <span class="nl">Source:</span>   <span class="nl">https:</span><span class="c1">//github.com/rs/SDWebImage.git</span>
</span><span class='line'>   <span class="o">-</span> <span class="nl">Versions:</span> <span class="mf">3.5.1</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">,</span> <span class="mf">3.2</span><span class="p">,</span> <span class="mf">3.1</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">2.7.4</span><span class="p">,</span> <span class="mf">2.7</span><span class="p">,</span> <span class="mf">2.6</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">2.4</span>
</span><span class='line'>   <span class="p">[</span><span class="n">master</span> <span class="n">repo</span><span class="p">]</span>
</span><span class='line'>   <span class="o">-</span> <span class="n">Sub</span> <span class="nl">specs:</span>
</span><span class='line'>     <span class="o">-</span> <span class="n">SDWebImage</span><span class="o">/</span><span class="n">Core</span> <span class="p">(</span><span class="mf">3.5.1</span><span class="p">)</span>
</span><span class='line'>     <span class="o">-</span> <span class="n">SDWebImage</span><span class="o">/</span><span class="n">MapKit</span> <span class="p">(</span><span class="mf">3.5.1</span><span class="p">)</span>
</span><span class='line'>     <span class="o">-</span> <span class="n">SDWebImage</span><span class="o">/</span><span class="n">WebP</span> <span class="p">(</span><span class="mf">3.5.1</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>
注：我省略了两个库，没有全列出。</p>

<h3>使用</h3>

<p>假设我的Desktop上有一个已经存在的一个项目名称叫做：<em>CocoaPodsTest</em>，首先，进入项目的根目录，并在根目录下创建一个名叫Podfile的文件（没有任何后缀）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="err">$</span> <span class="n">cd</span> <span class="n">Desktop</span><span class="o">/</span><span class="n">CocoaPodsTest</span><span class="o">/</span>       <span class="err">&#39;进入项目根目录，根据自己项目实际目录&#39;</span>
</span><span class='line'><span class="err">$</span> <span class="n">vim</span> <span class="n">Podfile</span>   <span class="err">&#39;创建</span><span class="n">Podfile</span><span class="err">文件，你可以选择你自己喜欢的编辑器&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>
注：vim的简单用法，<code>$ vim fileName</code>创建文件fileName，并打开；按<code>i</code>进入插入模式，输入文本；按<code>esc</code>进入命令模式后，按<code>:wq</code>或<code>ZZ</code>退出并保存。</p>

<p>然后，在Podfile文件中按以下的格式将依赖库的名字列出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">platform</span> <span class="o">:</span><span class="n">ios</span><span class="p">,</span> <span class="err">&#39;</span><span class="mf">6.0</span><span class="err">&#39;</span>                <span class="err">&#39;平台、版本&#39;</span>
</span><span class='line'><span class="n">pod</span> <span class="err">&#39;</span><span class="n">SDWebImage</span><span class="err">&#39;</span><span class="p">,</span> <span class="err">&#39;</span><span class="o">~&gt;</span> <span class="mf">3.5.1</span><span class="err">&#39;</span>       <span class="err">&#39;开源库名称、版本&#39;</span>
</span><span class='line'><span class="n">pod</span> <span class="err">&#39;</span><span class="n">AFNetworking</span><span class="err">&#39;</span><span class="p">,</span> <span class="err">&#39;</span><span class="o">~&gt;</span> <span class="mf">2.0.3</span><span class="err">&#39;</span>     <span class="err">&#39;开源库名称、版本&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>
保存Podfile文件后，执行如下安装的命令:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="err">$</span> <span class="n">pod</span> <span class="n">install</span>
</span></code></pre></td></tr></table></div></figure>


<p>
当安装命令执行成功后，会输出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">Analyzing</span> <span class="n">dependencies</span>
</span><span class='line'><span class="n">Downloading</span> <span class="n">dependencies</span>
</span><span class='line'><span class="n">Installing</span> <span class="n">AFNetworking</span> <span class="p">(</span><span class="mf">2.0.3</span><span class="p">)</span>
</span><span class='line'><span class="n">Installing</span> <span class="n">SDWebImage</span> <span class="p">(</span><span class="mf">3.5.1</span><span class="p">)</span>
</span><span class='line'><span class="n">Generating</span> <span class="n">Pods</span> <span class="n">project</span>
</span><span class='line'><span class="n">Integrating</span> <span class="n">client</span> <span class="n">project</span>
</span><span class='line'><span class="p">[</span><span class="o">!</span><span class="p">]</span> <span class="n">From</span> <span class="n">now</span> <span class="n">on</span> <span class="n">use</span> <span class="err">`</span><span class="n">CocoaPodsTest</span><span class="p">.</span><span class="n">xcworkspace</span><span class="err">`</span><span class="p">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>
哈哈，看到类似这样的输出就是成功了。你所需要的第三方开源库都下载好了，并且设置好了相应的依赖以及编译参数。在我们以后用的时候一定要记住以下两点：</p>

<p><strong>1. 最后一行是一个警告，提醒我们需要注意：从现在开始，需要通过<code>xxx.xcworkspace</code>打开的我们的项目。而不是之前我们一直用的<code>xxx.xcodeproj</code></strong></p>

<p><strong>2. 当我们每次修改了<code>Podfile</code>这个文件后，一定要记得执行命令：<code>$ pod install</code>，还可以执行<code>$ pod update</code>来更新类库</strong></p>

<h3>总结</h3>

<p>用CocoaPods给我们的iOS项目添加依赖库真的太方便了，几个命令就搞定了，我个人建议像我一样还不会使用CocoaPods进行项目依赖的初级开发者，尤其是像我这样刚毕业的本科生，这个工具有必要学会，不能被鄙视，更能提高效率</p>

<p>有很多iOS大牛早已写了关于cocoaPods的相关教程，我个人又参考各大牛的博客写了一遍，只为能增加使用CocoaPods的熟练度。如有造成侵权行为，请联系本人</p>

<h3>相关链接</h3>

<p><a href="http://blog.devtang.com/blog/2012/12/02/use-cocoapod-to-manage-ios-lib-dependency/">唐巧的技术博客</a></p>

<p><a href="http://blog.cocoapods.org">CocoaPods Blog</a></p>

<p><a href="http://code4app.com/article/cocoapods-install-usage">CocoaPods安装和使用教程</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[起点iOS技术博客]]></title>
    <link href="http://itdongbaojun.github.io/blog/2013/12/04/qi-dian-iosji-zhu-bo-ke/"/>
    <updated>2013-12-04T23:23:08+08:00</updated>
    <id>http://itdongbaojun.github.io/blog/2013/12/04/qi-dian-iosji-zhu-bo-ke</id>
    <content type="html"><![CDATA[<h3>新起点</h3>

<p><em>2013</em>年<em>07</em>月大学毕业，<em>2013</em>年<em>07</em>月<em>19</em>日入职到现在的公司——<strong>北京国信灵通网络科技有限公司</strong>。至今天，<em>2013</em>年<em>12</em>月<em>04</em>日，已经快有<em>5</em>个月的时间，虽然之前有过将近一年的iOS开发实习的经历，但依然将此刻作为新的起点。用博客的来记录在<strong>iOS开发</strong>这条路上的点滴。</p>
]]></content>
  </entry>
  
</feed>
